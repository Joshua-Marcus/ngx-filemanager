(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('@ctrl/ngx-csv', ['exports', '@angular/core', '@angular/platform-browser'], factory) :
    (global = global || self, factory((global.ctrl = global.ctrl || {}, global.ctrl['ngx-csv'] = {}), global.ng.core, global.ng.platformBrowser));
}(this, function (exports, core, platformBrowser) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var isJsons = function (array) {
        return Array.isArray(array) &&
            array.every(function (row) { return typeof row === 'object' && !(row instanceof Array); });
    };
    var isArrays = function (array) {
        return Array.isArray(array) && array.every(function (row) { return Array.isArray(row); });
    };
    function jsonsHeaders(array) {
        return Array.from(new Set(array.map(function (item) { return Object.keys(item); }).reduce(function (a, b) { return __spread(a, b); }, [])));
    }
    function jsons2arrays(jsons, headers) {
        headers = headers || jsonsHeaders(jsons);
        // allow headers to have custom labels, defaulting to having the header data key be the label
        var headerLabels = headers;
        var headerKeys = headers;
        if (isJsons(headers)) {
            headerLabels = headers.map(function (header) { return header.label; });
            headerKeys = headers.map(function (header) { return header.key; });
        }
        var data = jsons.map(function (object) {
            return headerKeys.map(function (header) { return (header in object ? object[header] : ''); });
        });
        return __spread([headerLabels], data);
    }
    var elementOrEmpty = function (element) {
        return element || element === 0 ? element : '';
    };
    function joiner(data, delimiter) {
        if (delimiter === void 0) { delimiter = ','; }
        return data
            .map(function (row, index) {
            return row.map(function (element) { return '"' + elementOrEmpty(element) + '"'; }).join(delimiter);
        })
            .join("\n");
    }
    function arrays2csv(data, headers, delimiter) {
        return joiner(headers ? __spread([headers], data) : data, delimiter);
    }
    function jsons2csv(data, headers, delimiter) {
        return joiner(jsons2arrays(data, headers), delimiter);
    }
    function string2csv(data, headers, delimiter) {
        return headers ? headers.join(delimiter) + "\n" + data : data;
    }
    function toCSV(data, headers, delimiter) {
        if (isJsons(data)) {
            return jsons2csv(data, headers, delimiter);
        }
        if (isArrays(data)) {
            return arrays2csv(data, headers, delimiter);
        }
        if (typeof data === 'string') {
            return string2csv(data, headers, delimiter);
        }
        throw new TypeError("Data should be a \"String\", \"Array of arrays\" OR \"Array of objects\" ");
    }
    function buildURI(data, uFEFF, headers, delimiter) {
        if (uFEFF === void 0) { uFEFF = true; }
        var csv = toCSV(data, headers, delimiter);
        var blob = new Blob([uFEFF ? '\uFEFF' : '', csv], { type: 'text/csv' });
        return URL.createObjectURL(blob);
    }

    var CsvDirective = /** @class */ (function () {
        function CsvDirective(sanitizer) {
            this.sanitizer = sanitizer;
            /** the body of the csv */
            this.data = [];
            /** Set the seperator between values */
            this.delimiter = ',';
            /** adds a Byte order mark to setup the csv as UTF-8  */
            this.uFEFF = true;
            /** filename */
            this.download = 'data.csv';
            this.target = '_blank';
        }
        Object.defineProperty(CsvDirective.prototype, "filename", {
            /** Set the filename of the csv. Default is `data.csv` */
            set: function (a) {
                this.download = a;
            },
            enumerable: true,
            configurable: true
        });
        CsvDirective.prototype.ngOnChanges = function () {
            this.href = this.sanitizer.bypassSecurityTrustResourceUrl(buildURI(this.data, this.uFEFF, this.headers, this.delimiter));
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "data", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], CsvDirective.prototype, "headers", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "delimiter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], CsvDirective.prototype, "filename", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "uFEFF", void 0);
        __decorate([
            core.HostBinding(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "href", void 0);
        __decorate([
            core.HostBinding(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "download", void 0);
        __decorate([
            core.Input(), core.HostBinding(),
            __metadata("design:type", Object)
        ], CsvDirective.prototype, "target", void 0);
        CsvDirective = __decorate([
            core.Directive({ selector: '[csvLink]' }),
            __metadata("design:paramtypes", [platformBrowser.DomSanitizer])
        ], CsvDirective);
        return CsvDirective;
    }());

    var CsvModule = /** @class */ (function () {
        function CsvModule() {
        }
        CsvModule = __decorate([
            core.NgModule({
                declarations: [CsvDirective],
                exports: [CsvDirective],
            })
        ], CsvModule);
        return CsvModule;
    }());

    exports.CsvDirective = CsvDirective;
    exports.CsvModule = CsvModule;
    exports.arrays2csv = arrays2csv;
    exports.buildURI = buildURI;
    exports.elementOrEmpty = elementOrEmpty;
    exports.isArrays = isArrays;
    exports.isJsons = isJsons;
    exports.joiner = joiner;
    exports.jsons2arrays = jsons2arrays;
    exports.jsons2csv = jsons2csv;
    exports.jsonsHeaders = jsonsHeaders;
    exports.string2csv = string2csv;
    exports.toCSV = toCSV;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ctrl-ngx-csv.umd.js.map
